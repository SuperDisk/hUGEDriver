;; hUGETracker playback routine
;; Written by SuperDisk 2019

include "hardware.inc"
include "constants.inc"
include "debug_macros.inc"

include "constants.htt"

dn: MACRO ;; (note, instr, effect)
    db \1
    db ((\2 << 4) | (\3 >> 8))
    db LOW(\3)
ENDM

add_a_to_r16: MACRO
    add \2
    ld \2, a
    adc \1
    sub \2
    ld \1, a
ENDM

;; Thanks PinoBatch!
sub_from_r16: MACRO ;; (high, low, value)
    ld a, \2
    sub \3
    ld \2, a
    sbc a  ; A = -1 if borrow or 0 if not
    add \1
    ld \1, a
ENDM

add_a_to_hl: MACRO
    add_a_to_r16 h, l
ENDM

add_a_to_de: MACRO
    add_a_to_r16 d, e
ENDM

ret_dont_call_playnote: MACRO
    pop hl
    pop af
    ld a, 6 ; How many bytes until the next channel's code
    add_a_to_hl
    jp hl
ENDM

; Constants
STACK_SIZE EQU $7A
;; Stack starts at $FFFE

PATTERN_LENGTH EQU 64

; $0000 - $003F: RST handlers.

if DEF (STANDALONE_MODE)
IF !DEF(GBS_MODE)

SECTION "restarts", ROM0[$0000]
ret
REPT 7
    nop
ENDR
; $0008
ret
REPT 7
    nop
ENDR
; $0010
ret
REPT 7
    nop
ENDR
; $0018
ret
REPT 7
    nop
ENDR
; $0020
ret
REPT 7
    nop
ENDR
; $0028
ret
REPT 7
    nop
ENDR
; $0030
ret
REPT 7
    nop
ENDR
; $0038
ret
REPT 7
    nop
ENDR

; Interrupt addresses
SECTION "Vblank interrupt", ROM0[$0040]
    reti

SECTION "LCD controller status interrupt", ROM0[$0048]
    call hUGE_dosound
    reti

SECTION "Timer overflow interrupt", ROM0[$0050]
    reti

SECTION "Serial transfer completion interrupt", ROM0[$0058]
    reti

SECTION "P10-P13 signal low edge interrupt", ROM0[$0060]
    reti

; Reserved stack space
SECTION "Stack", HRAM[$FFFE - STACK_SIZE]
    ds STACK_SIZE

; Control starts here, but there's more ROM header several bytes later, so the
; only thing we can really do is immediately jump to after the header

SECTION "init", ROM0[$0100]
    nop
    jp $0150

SECTION "romname", ROM0[$0134]
; $0134 - $013E: The title, in upper-case letters, followed by zeroes.
DB "HUGE"
DS 7 ; padding
; $013F - $0142: The manufacturer code. Empty for now
DS 4
DS 1
; $0144 - $0145: "New" Licensee Code, a two character name.
DB "NF"

ENDC ; !GBS_MODE

;; TODO: Fix this so it fully conforms to the spec!!!!!!!!!!
IF DEF(GBS_MODE)
SECTION "GBS Header", ROM0[$0]
db "GBS" ; magic
db 1 ; version (always 1)
db 1 ; num songs
db 1 ; first song
dw $70 ; load address
dw hUGE_init ; init address
dw hUGE_dosound ; play address
dw $fffe ; stack pointer
db 0
db 0
db GBS_TITLE
db GBS_AUTHOR
db GBS_COPYRIGHT
ENDC ; GBS_MODE
ENDC ; STANDALONE_MODE

SECTION "Song Data", ROM0

;;;;;;;;;;;
;; Orders
;;;;;;;;;;;

include "order.htt"

;;;;;;;;;;;;
;; Patterns
;;;;;;;;;;;;

include "pattern.htt"

;;;;;;;;;;;;;;;;
;; Instruments
;;;;;;;;;;;;;;;;

duty_instruments:

include "duty_instrument.htt"

wave_instruments:

include "wave_instrument.htt"

noise_instruments:

include "noise_instrument.htt"

;;;;;;;;;;;;;
;; Routines
;;;;;;;;;;;;;

routines:

loadRoutine: MACRO
__hUGE_Routine_\1:
include "routine\1.htt"
__end_hUGE_Routine_\1:
ds 16 - (__end_hUGE_Routine_\1 - __hUGE_Routine_\1)
ENDM

  loadRoutine 0
  loadRoutine 1
  loadRoutine 2
  loadRoutine 3
  loadRoutine 4
  loadRoutine 5
  loadRoutine 6
  loadRoutine 7
  loadRoutine 8
  loadRoutine 9
  loadRoutine 10
  loadRoutine 11
  loadRoutine 12
  loadRoutine 13
  loadRoutine 14
  loadRoutine 15

;;;;;;;;;
;; Waves
;;;;;;;;;

waves:

include "wave.htt"

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

SECTION "Note Table", ROM0
note_table:
include "music.inc"

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

SECTION "Playback variables", WRAM0
_start_vars:


pattern1: dw
pattern2: dw
pattern3: dw
pattern4: dw

ticks_per_row: db
current_order: db
next_order: dw
row_break: db

temp_note_value: dw
row: db
tick: db
counter: db
current_wave: db

;; Size of a channel in bytes
CHANNEL_SIZE EQU 8
;; Amount to be shifted in order to skip a channel.
CHANNEL_SIZE_EXPONENT EQU 3

channels:

;;;;;;;;;;;
;;Channel 1
;;;;;;;;;;;
channel1:
channel_period1: dw
toneporta_target1: dw
channel_note1: db
vibrato_tremolo_phase1: db
envelope1: db
highmask1: db

;;;;;;;;;;;
;;Channel 2
;;;;;;;;;;;
channel2:
channel_period2: dw
toneporta_target2: dw
channel_note2: db
vibrato_tremolo_phase2: db
envelope2: db
highmask2: db

;;;;;;;;;;;
;;Channel 3
;;;;;;;;;;;
channel3:
channel_period3: dw
toneporta_target3: dw
channel_note3: db
vibrato_tremolo_phase3: db
envelope3: db
highmask3: db

;;;;;;;;;;;
;;Channel 4
;;;;;;;;;;;
channel4:
channel_period4: dw
toneporta_target4: dw
channel_note4: db
vibrato_tremolo_phase4: db
envelope4: db
highmask4: db

_end_vars:

if DEF(STANDALONE_MODE)

if !DEF(GBS_MODE)
SECTION "main", ROM0[$0150]
jp hUGE_init
ELSE
SECTION "main", ROM0
ENDC ; !GBS_MODE

ELSE
SECTION "main", ROM0
ENDC

IF DEF(STANDALONE_MODE)
_paint_tile:
    ld a, b
    ld [hl+], a
    ld a, c
    ld [hl+], a
    ret
ENDC

hUGE_init::
  IF DEF(STANDALONE_MODE)
    ; Set LCD palette for grayscale mode; yes, it has a palette
    ld a, %11100100
    ld [$FF00+$47], a

    ;; Fill with pattern
    ld hl, $8000
    ld bc, `10000000
    call _paint_tile
    ld bc, `01000000
    call _paint_tile
    ld bc, `00100000
    call _paint_tile
    ld bc, `00010000
    call _paint_tile
    ld bc, `00001000
    call _paint_tile
    ld bc, `00000100
    call _paint_tile
    ld bc, `00000010
    call _paint_tile
    ld bc, `00000001
    call _paint_tile
  ENDC ; STANDALONE_MODE

    ;; Zero some ram
IF !DEF(PREVIEW_MODE)
    ld a, _end_vars - _start_vars
    ld hl, _start_vars
.fill_loop:
    ld [hl], 0
    inc hl
    dec a
    jp nz, .fill_loop
ENDC

    ;; Force the load of the wave on the first note
    ld a, 100
    ld [current_wave], a

    ;; Load starting speed (7 ticks per row)
    ld a, TICKS
    ld [ticks_per_row], a

    ; Enable sound globally
    ld a, $80
    ld [rAUDENA], a
    ; Enable all channels in stereo
    ld a, $FF
    ld [rAUDTERM], a
    ; Set volume
    ld a, $77
    ld [rAUDVOL], a

    ;; Enable chanel 3
    ld a, %10000000
    ld [rAUD3ENA], a
    ld a, $ff ;; full length (although this does nothing)
    ld [rAUD3LEN], a
    ld a, %0000000 ; 0%
    ld [rAUD3LEVEL], a

    ld a, [current_order]
    ld c, a ;; Current order index
    call _refresh_patterns

	if DEF(STANDALONE_MODE)
    ;; Enable the HBlank interrupt on scanline 0
    ld a, [rSTAT]
    or a, STATF_LYC
    ld [rSTAT], a
    xor a ; ld a, 0
    ld [rLYC], a

    ld a, IEF_LCDC ; IEF_VBLANK;  | IEF_LCDC ; IEF_HILO | IEF_TIMER
    ld [rIE], a
    ei
	ENDC

IF !DEF(GBS_MODE) && DEF(STANDALONE_MODE)
    jp _halt
ELSE
    ret
ENDC

_refresh_patterns:
;; Loads pattern registers with pointers to correct pattern based on
;; an order index

;; Call with c set to what order to load
load_pattern: MACRO
    ld h, 0
    ld l, c
    ld de, \1
    add hl, de

    ld a, [hl+]
    ld [\2], a
    ld a, [hl+]
    ld [\2+1], a
ENDM
    load_pattern order1, pattern1
    load_pattern order2, pattern2
    load_pattern order3, pattern3
    load_pattern order4, pattern4
    ret

_load_note_data:
    ;; Call with:
    ;; Pattern pointer in BC

    ;; Stores instrument/effect code in B
    ;; Stores effect params in C
    ;; Stores note number in A
    ld a, [row]
    ld h, a
    ;; Multiply by 3 for the note value
    add h
    add h

    add 2
    ld h, 0
    ld l, a
    add hl, bc ; HL now points at the 3rd byte of the note
    ld a, [hl-]
    ld c, a
    ld a, [hl-]
    ld b, a

    ld a, [hl]

    ret

_lookup_note:
    ;; Call with:
    ;; Pattern pointer in BC
    ;; channel_noteX pointer in DE

    ;; Stores note period value in HL
    ;; Stores instrument/effect code in B
    ;; Stores effect params in C
    ;; Stores note number in the memory pointed to by DE
    call _load_note_data
    ld hl, 0

    ;; If the note we found is greater than LAST_NOTE, then it's not a valid note
    ;; and nothing needs to be updated.
    cp LAST_NOTE
    ret nc

    ;; Store the loaded note value in channel_noteX
    ld h, d
    ld l, e
    ld [hl], a

_convert_note:
    ;; Call with:
    ;; Note number in A
    ;; Stores note period value in HL

    add a ;; double it to get index into hi/lo table

    ld hl, note_table
    add_a_to_hl
    ld     a, [hl+]
    ld     h, [hl]
    ld     l, a

    ;; Need to clear the carry flag-- this complements it, but since the last
    ;; thing that modified the flag always sets it, this will clear it.
    ccf
    ret

_convert_ch4_note:
    ;; Call with:
    ;; Note number in A
    ;; Stores polynomial counter in A
    ;; Free: HL

    ;; Invert the order of the numbers
    add 192 ; (255 - 63)
    cpl

    ;; Thanks to RichardULZ for this formula
    ;; https://docs.google.com/spreadsheets/d/1O9OTAHgLk1SUt972w88uVHp44w7HKEbS/edit#gid=75028951
    ; if A > 7 then begin
    ;   B := (A-4) div 4;
    ;   C := (A mod 4)+4;
    ;   A := (C or (B shl 4))
    ; end;

    ; if A < 7 then return
    cp 7
    ret c

    ld h, a

    ; B := (A-4) div 4;
    sub 4
    srl a
    srl a
    ld l, a

    ; C := (A mod 4)+4;
    ld a, h
    and 3
    add 4

    ; A := (C or (B shl 4))
    swap l
    or l
    ret

_update_channel:
    ;; Call with:
    ;; Channel in B
    ;; Note tone in DE

    ld a, b
    cp 3
    jr z, _update_channel4
    cp 1
    jr c, _update_channel1
    jr z, _update_channel2
_update_channel3:
    ld hl, highmask3
    ld a, e
    ld [rAUD3LOW], a
    ld a, d
    ld [rAUD3HIGH], a
    ret
_update_channel1:
    ld hl, highmask1
    ld a, e
    ld [rAUD1LOW], a
    ld a, d
    ld [rAUD1HIGH], a
    ret
_update_channel2:
    ld hl, highmask2
    ld a, e
    ld [rAUD2LOW], a
    ld a, d
    ld [rAUD2HIGH], a
    ret
_update_channel4:
    ld hl, highmask4
    ;; TODO: Come back here
    ; call _quantize_channel4_note
    ; ld [rAUD4POLY], a
    ; ld a, [hl]
    ; and %01111111
    ; ld a, 0
    xor a
    ld [rAUD4GO], a
    ret

_playnote1:
    ;; Call with:

    ;; Play a note on channel 1 (square wave)
    ld a, [temp_note_value+1]
    ld [channel_period1], a
    ld [rAUD1LOW], a

    ld a, [temp_note_value]
    ld [channel_period1+1], a

    ;; Get the highmask and apply it.
    ld hl, highmask1
    or [hl]
    ld [rAUD1HIGH], a

    ret

_playnote2:
    ;; Play a note on channel 2 (square wave)
    ld a, [temp_note_value+1]
    ld [channel_period2], a
    ld [rAUD2LOW], a

    ld a, [temp_note_value]
    ld [channel_period2+1], a

    ;; Get the highmask and apply it.
    ld hl, highmask2
    or [hl]
    ld [rAUD2HIGH], a

    ret

_playnote3:
    ;; This fixes a gameboy hardware quirk, apparently.
    ;; The problem is emulated accurately in BGB.
    ;; https://gbdev.gg8.se/wiki/articles/Gameboy_sound_hardware
    xor a
    ld [rAUD3ENA], a
    ld a, %10000000
    ld [rAUD3ENA], a

    ;; Play a note on channel 3 (waveform)
    ld a, [temp_note_value+1]
    ld [channel_period3], a
    ld [rAUD3LOW], a

    ld a, [temp_note_value]
    ld [channel_period3+1], a

    ;; Get the highmask and apply it.
    ld hl, highmask3
    or [hl]
    ld [rAUD3HIGH], a

    ret

_playnote4:
    ;; Play a "note" on channel 4 (noise)
    ld a, [temp_note_value]
    ld [rAUD4POLY], a

    ;; Get the highmask and apply it.
    ld a, [highmask4]
    ld [rAUD4GO], a

    ret

_doeffect:
    ;; Call with:
    ;; B: instrument nibble + effect type nibble
    ;; C: effect parameters
    ;; E: channel

    ;; free: A, D, H, L

    ;; Strip the instrument bits off leaving only effect code
    ld a, b
    and %00001111
    ld b, a

    ;; Multiply by 3 to get offset into table
    ld a, b
    add a, b
    add a, b

    ld hl, .jump
    add_a_to_hl

    ld b, e
    ld a, [tick]
    cp 0
    ; or a ; We can return right off the bat if it's tick zero
    jp hl

.jump:
    ;; Jump table for effect
    jp fx_arpeggio                     ;0xy
    jp fx_porta_up                     ;1xy
    jp fx_porta_down                   ;2xy
    jp fx_toneporta                    ;3xy
    jp fx_vibrato                      ;4xy
    jp fx_set_master_volume            ;5xy
    jp fx_call_routine                 ;6xy
    jp fx_note_delay                   ;7xy
    jp fx_set_pan                      ;8xy
    jp fx_set_duty                     ;9xy
    jp fx_vol_slide                    ;Axy
    jp fx_pos_jump                     ;Bxy
    jp fx_set_volume                   ;Cxy
    jp fx_pattern_break                ;Dxy
    jp fx_note_cut                     ;Exy
    jp fx_set_speed                    ;Fxy

setup_channel_pointer:
    ;; Call with:
    ;; Channel value in B
    ;; Offset in D
    ;; Returns value in HL

    ld a, b
    REPT CHANNEL_SIZE_EXPONENT
        add a
    ENDR
    add d
    ld hl, channels
    add_a_to_hl
    ret

fx_set_master_volume:
    ret nz
    ;; B: channel
    ;; C: effect parameters

    ;; free registers: A, D, E, H, L

    ;; Upper 4 bits contain volume for left, lower 4 bits for right
    ;; Format is ?LLL ?RRR where ? is just a random bit, since we don't use
    ;; the Vin

    ;; This can be used as a more fine grained control over channel 3's output,
    ;; if you pan it completely.

    ld a, c
    ld [rAUDVOL], a
    ret

fx_call_routine:
    ;; B: channel
    ;; C: effect parameters

    ;; free registers: A, D, E, H, L

    ;; Routines are 16 bytes. Shift left to multiply by 16, then
    ;; jump to that location.

    ld hl, routines
    ld a, c
    swap a
    add_a_to_hl
    jp hl

fx_set_pan:
    ret nz

    ;; B: channel
    ;; C: effect parameters

    ;; free registers: A, D, E, H, L

    ;; Pretty simple. The editor can create the correct value here without a bunch
    ;; of bit shifting manually.

    ld a, c
    ld [rAUDTERM], a
    ret

fx_set_duty:
    ret nz

    ;; B: channel
    ;; C: effect parameters

    ;; free registers: A, D, E, H, L

    ;; $900 = 12.5%
    ;; $940 = 25%
    ;; $980 = 50%
    ;; $9C0 = 75%

    ld a, b
    or a ; cp 0
    ld a, c
    jr z, .chan1
.chan2:
    ld [rAUD2LEN], a
    ret
.chan1:
    ld [rAUD1LEN], a
    ret

fx_vol_slide:
    ret nz

    ;; This is really more of a "retrigger note with lower volume" effect and thus
    ;; isn't really that useful. Instrument envelopes should be used instead.
    ;; Might replace this effect with something different if a new effect is
    ;; ever needed.

    ;; B: channel
    ;; C: effect parameters

    ;; free registers: A, D, E, H, L

    ld d, 0
    call setup_channel_pointer
    ld a, [hl+]
    ld [temp_note_value+1], a
    ld a, [hl]
    ld [temp_note_value], a

    ld a, b
    add a
    ld hl, _envelope_registers
    add_a_to_hl
    ld a, [hl+]
    ld h, [hl]
    ld l, a

    ;; setup the up and down params
    ld a, c
    and %00001111
    ld d, a

    ld a, c
    and %11110000
    ld e, a
    swap e

    ld a, [hl]
    and %11110000
    swap a
    sub d
    jr nc, .cont1
    ld a, 0
.cont1:
    add e
    cp $10
    jr c, .cont2
    ld a, $F
.cont2:
    swap a
    ld [hl+], a

    inc hl
    ld a, [hl]
    or %10000000
    ld [hl], a

    ld hl, _play_note_routines
    ld a, b
    add b
    add b
    add_a_to_hl
    jp hl

_envelope_registers:
    dw rAUD1ENV
    dw rAUD2ENV
    dw rAUD3LEVEL
    dw rAUD4ENV

fx_note_delay:
    ;; B: channel
    ;; C: effect parameters

    ;; free registers: A, D, E, H, L

    jr nz, .play_note

    ;; Just store the note into the channel period, and don't play a note.
    ld d, 0
    call setup_channel_pointer

    ld a, [temp_note_value]
    ld [hl+], a
    ld a, [temp_note_value+1]
    ld [hl], a

    ;; Don't call _playnote. This is done by grabbing the return
    ;; address and manually skipping the next call instruction.
    ret_dont_call_playnote

.play_note:
    ld a, [tick]
    cp c
    ret nz ; wait until the correct tick to play the note

    ld d, 0
    call setup_channel_pointer

    ;; TODO: Change this to accept HL instead?
    ld a, [hl+]
    ld [temp_note_value], a
    ld a, [hl]
    ld [temp_note_value+1], a

    ;; TODO: Generalize this somehow?

    ld hl, _play_note_routines
    ld a, b
    add b
    add b
    add_a_to_hl
    jp hl

_play_note_routines:
    jp _playnote1
    jp _playnote2
    jp _playnote3
    jp _playnote4

fx_set_speed:
    ret nz

    ;; B: channel
    ;; C: effect parameters

    ;; free registers: A, D, E, H, L
    ld a, c
    ld [ticks_per_row], a
    ret

fx_pos_jump:
    ;; B: channel
    ;; C: effect parameters

    ;; free registers: A, D, E, H, L

    ld a, 1
    ld [row_break], a
    ld a, c
    ld [next_order], a

    ret

fx_pattern_break:
    ;; B: channel
    ;; C: effect parameters

    ;; free registers: A, D, E, H, L

    ld a, c
    ld [row_break], a

    ret

fx_note_cut:
    ;; B: channel
    ;; C: effect parameters

    ;; free registers: A, D, E, H, L
    ; ld a, [tick]
    cp c
    ret nz

    ld hl, rAUD1ENV
    ld a, b
    add a
    add a
    add b ; multiply by 5
    add_a_to_hl
    ld [hl], 0
    ld a, b
    cp 2
    ret z ; return early if CH3-- no need to retrigger note

    ;; Retrigger note
    inc hl
    inc hl
    ld [hl], %11111111
    ret

fx_set_volume:
    ret nz ;; Return if we're not on tick zero.

    ;; B: channel
    ;; C: effect parameters

    ;; free registers: A, D, E, H, L

    ;; Arguments to this effect will be massaged to correct form for the channel
    ;; in the editor so we don't have to AND and SWAP and stuff.

set_channel_volume:
    ;; Call with:
    ;; Correct volume value in C
    ;; Channel number in B

    ld a, b
    cp 3 ; check if it's channel 4
    jr z, set_chn_4_vol
    cp 1 ; check if it's channel 2
    jr c, set_chn_1_vol
    jr z, set_chn_2_vol
set_chn_3_vol:
    ;; "Quantize" the more finely grained volume control down to one of 4 values.
    ld a, c
    cp 10
    jr nc, .one
    cp 5
    jr nc, .two
    cp 0
    jr z, .zero
.three:
    ld a, %01100000
    jr .done
.two:
    ld a, %01000000
    jr .done
.one:
    ld a, %00100000
    jr .done
.zero:
    xor a
.done:
    ld [rAUD3LEVEL], a
    ret
set_chn_2_vol:
    ld a, [rAUD2ENV]
    and %00001111
    swap c
    or c
    ld [rAUD2ENV], a
    ret
set_chn_1_vol:
    ld a, [rAUD1ENV]
    and %00001111
    swap c
    or c
    ld [rAUD1ENV], a
    ret
set_chn_4_vol:
    swap c
    ld a, c
    ld [rAUD4ENV], a
    ret

fx_vibrato:
    ret z
    ;; B: channel
    ;; C: effect parameters

    ;; free registers: A, D, E, H, L

    ;; Extremely poor man's vibrato.
    ;; Speed values:
    ;; (0x0  = 1.0)
    ;; (0x1  = 0.5)
    ;; (0x3  = 0.25)
    ;; (0x7  = 0.125)
    ;; (0xf  = 0.0625)
    ld d, 4
    call setup_channel_pointer

    ld a, c
    and %11110000
    swap a
    ld d, a

    ;; If it's the last tick, then reset the tone to its normal value so we
    ;; don't screw the tone when the vibrato gets turned off!
    ld a, [ticks_per_row]
    dec a
    ld e, a
    ld a, [counter]
    cp e
    jr z, .restore

    and d
    ld a, [hl-]
    jr z, .go_up
.restore:
    call _convert_note
    jr .finish_vibrato
.go_up:
    call _convert_note
    ld a, c
    and %00001111
    add_a_to_hl
.finish_vibrato:
    ld d, h
    ld e, l
    jp _update_channel

fx_arpeggio:
    ret z
    ;; B: channel
    ;; C: effect parameters

    ;; free registers: A, D, E, H, L

    ld d, 4
    call setup_channel_pointer

    ld a, [tick]
    dec a

    ;; A crappy modulo, because it's not a multiple of four :(

    jr .test_greater_than_two
.greater_than_two:
    sub a, 3
.test_greater_than_two:
    cp 3
    jr nc, .greater_than_two

    ;; Multiply by 2 to get offset into table
    add a

    ld d, [hl]

    ld hl, .arp_options
    add_a_to_hl
    jp hl

.arp_options:
    jr .set_arp1
    jr .set_arp2
    jr .reset_arp
.reset_arp:
    ld a, d
    jr .finish_skip_add
.set_arp2:
    ld a, c
    swap a
    jr .finish_arp
.set_arp1:
    ld a, c
.finish_arp:
    and %00001111
    add d
.finish_skip_add:
    call _convert_note
    ld d, h
    ld e, l
    jp _update_channel

fx_porta_up:
    ret z
    ;; B: channel
    ;; C: effect parameters

    ;; free registers: A, D, E, H, L

    ld d, 0
    call setup_channel_pointer

    ld a, [hl+]
    ld e, a
    ld d, [hl]

    ld a, c
    add_a_to_de

    ld a, d
    ld [hl-], a
    ld [hl], e

    jp _update_channel

;; TODO: Maybe merge with fx_porta_up, since they're so similar? Would need
;; to find a way to compare against effect code.
fx_porta_down:
    ret z
    ;; B: channel
    ;; C: effect parameters

    ;; free registers: A, D, E, H, L

    ld d, 0
    call setup_channel_pointer

    ld a, [hl+]
    ld e, a
    ld d, [hl]

    ld a, c
    sub_from_r16 d, e, c

    ld a, d
    ld [hl-], a
    ld [hl], e

    jp _update_channel

fx_toneporta:
    jr nz, .do_toneporta

    ;; We're on tick zero, so just move the temp note value into the toneporta target.
    ld d, 2
    call setup_channel_pointer

    ;; If the note is nonexistent, then just return
    ld a, [temp_note_value+1]
    or a
    jr z, .return_skip

    ld [hl+], a
    ld a, [temp_note_value]
    ld [hl], a

    ;; Don't call _playnote. This is done by grabbing the return
    ;; address and manually skipping the next call instruction.
.return_skip:
    ret_dont_call_playnote

.do_toneporta:
    ;; B: channel
    ;; C: effect parameters

    ;; free registers: A, D, E, H, L

    ;; TODO: Optimize. This usage of the stack isn't great but IMO it's
    ;; better than using the stack hack which forces all effects to screw with
    ;; pushing and popping. Most effects won't need to do this.
    ld d, 0
    call setup_channel_pointer
    push hl

    ld a, [hl+]
    ld e, a
    ld a, [hl+]
    ld d, a

    ld a, [hl+]
    ld h, [hl]
    ld l, a

    ;; Comparing which direction to move the current value
    ;; TODO: Optimize this!!!!

    ;; Compare high byte
    ld a, h

    cp d
    jr c, .subtract ; target is less than the current period
    jr z, .high_byte_same
    jr .add
.high_byte_same:
    ld a, l
    cp e
    jr c, .subtract ; the target is less than the current period
    jr z, .done ; both nibbles are the same so no portamento
.add:
    ld a, c
    add_a_to_de

    ld a, h
    cp d
    jr c, .set_exact
    jr nz, .done
    ld a, l
    cp e
    jr c, .set_exact

    jr .done

.subtract:
    push hl
    ld h, c
    sub_from_r16 d, e, h
    pop hl

    jr .done
.set_exact:
    ld d, h
    ld e, l
.done:
    pop hl
    ld a, e
    ld [hl+], a
    ld [hl], d

    jp _update_channel

loadShort: MACRO
    ld a, [\1]
    ld \3, a
    ld a, [\1 + 1]
    ld \2, a
ENDM

_setup_instrument_pointer:
    ;; Call with:
    ;; Instrument/High nibble of effect in B
    ;; Stores whether the instrument was real in the Z flag
    ;; Stores the instrument pointer in DE
    ld a, b
    and %11110000
    swap a
    ret z ; If there's no instrument, then return early.

    dec a ; Instrument 0 is "no instrument"

    ;; Shift left twice to multiply by 4
    add a
    add a

    ; ld de, instruments -- caller must do this
    add_a_to_de
    rla ; reset the Z flag
    ret

hUGE_dosound::
    ld a, [tick]
    or a
    jp nz, .process_effects

    ;; Note playback

    loadShort pattern1, b, c
    ld de, channel_note1
    call _lookup_note
    push af
    jr nc, .do_setvol1

    ld de, duty_instruments
    call _setup_instrument_pointer
    ld a, [highmask1]
    res 7, a ; Turn off the "initial" flag
    jr z, .write_mask1

    ld a, [de]
    inc de
    ld [rAUD1SWEEP], a
    ld a, [de]
    inc de
    ld [rAUD1LEN], a
    ld a, [de]
    ld [rAUD1ENV], a
    inc de
    ld a, [de]

.write_mask1:
    ld [highmask1], a

.do_setvol1:
    ld a, h
    ld [temp_note_value], a
    ld a, l
    ld [temp_note_value+1], a

    ld e, 0
    call _doeffect

    pop af

    jr nc, .after_note1

    call _playnote1

.after_note1:
    loadShort pattern2, b, c
    ld de, channel_note2
    call _lookup_note
    push af
    jr nc, .do_setvol2

    ld de, duty_instruments
    call _setup_instrument_pointer
    ld a, [highmask2]
    res 7, a ; Turn off the "initial" flag
    jr z, .write_mask2

    inc de
    ld a, [de]
    inc de
    ld [rAUD2LEN], a
    ld a, [de]
    ld [rAUD2ENV], a
    inc de
    ld a, [de]

.write_mask2:
    ld [highmask2], a

.do_setvol2:
    ld a, h
    ld [temp_note_value], a
    ld a, l
    ld [temp_note_value+1], a

    ld e, 1
    call _doeffect

    pop af

    jr nc, .after_note2

    call _playnote2

.after_note2:
    loadShort pattern3, b, c
    ld de, channel_note3
    call _lookup_note

    ld a, h
    ld [temp_note_value], a
    ld a, l
    ld [temp_note_value+1], a

    push af

    jr nc, .do_setvol3

    ld de, wave_instruments
    call _setup_instrument_pointer
    ld a, [highmask3]
    res 7, a ; Turn off the "initial" flag
    jr z, .write_mask3

    ld a, [de]
    inc de
    ld [rAUD3LEN], a
    ld a, [de]
    inc de
    ld [rAUD3LEVEL], a
    ld a, [de]
    inc de

    ;; Check to see if we need to copy a wave and then do so
    ld hl, current_wave
    cp [hl]
    jr z, .no_wave_copy
    ld [hl], a
    swap a
    ld hl, waves
    add_a_to_hl
    xor a
    ld [rAUD3ENA], a

_addr = _AUD3WAVERAM
    REPT 16
    ld a, [hl+]
    ldh [_addr], a
_addr = _addr + 1
    ENDR
    ;; Aud3 will get re-enabled in playnote3

.no_wave_copy:
    ld a, [de]

.write_mask3:
    ld [highmask3], a

.do_setvol3:
    ld e, 2
    call _doeffect

    pop af
    jr nc, .after_note3

    call _playnote3

.after_note3:
    loadShort pattern4, b, c
    call _load_note_data
    ld [channel_note4], a
    cp LAST_NOTE
    push af
    jr nc, .do_setvol4

    call _convert_ch4_note
    ld [temp_note_value], a

    ld de, 0 ; noise_instruments
    call _setup_instrument_pointer

    ld a, [highmask4]
    res 7, a ; Turn off the "initial" flag
    jr z, .write_mask4

    ld hl, noise_instruments
    sla e
    add hl, de

    ld a, [hl+]
    ld [rAUD4ENV], a

    ld a, [hl]
    and %00111111
    ld [rAUD4LEN], a
    ld a, [hl]
    and %11000000
.write_mask4:
    ld [highmask4], a

.do_setvol4:
    ld e, 3
    call _doeffect

    pop af
    jr nc, .after_note4

    call _playnote4

.after_note4:
    ;; finally just update the tick/order/row values
    jp process_tick

.process_effects:
    ;; Only do effects if not on tick zero

    loadShort pattern1, b, c
    call _load_note_data

    ld a, c
    cp 0
    jr z, .after_effect1

    ld e, 0
    call _doeffect

.after_effect1:
    loadShort pattern2, b, c
    call _load_note_data

    ld a, c
    cp 0
    jr z, .after_effect2

    ld e, 1
    call _doeffect

.after_effect2:
    loadShort pattern3, b, c
    call _load_note_data

    ld a, c
    cp 0
    jr z, .after_effect3

    ld e, 2
    call _doeffect

.after_effect3:
    loadShort pattern4, b, c
    call _load_note_data
    cp LAST_NOTE
    jp nc, .done_macro
    ld h, a

    ld de, 0
    call _setup_instrument_pointer
    sla e

    ;; Manually add noise_instruments to de
    ld a, low(noise_instruments)
    add e
    ld e, a
    ld a, high(noise_instruments)
    adc d
    ld d, a

    ld a, [tick]
    cp 7
    jp nc, .done_macro

    inc a
    add_a_to_de
    ld a, [de]
    add h
    call _convert_ch4_note
    ld [rAUD4POLY], a
    xor a
    ld [rAUD4GO], a

.done_macro:
    ld a, c
    cp 0
    jr z, .after_effect4

    ld e, 3
    call _doeffect

.after_effect4:

process_tick:
    ld a, [counter]
    inc a
    ld [counter], a

    ld a, [ticks_per_row]
    ld b, a

    ld a, [tick]
    inc a

    cp b
    jp z, _newrow

    ld [tick], a
    ret

_newrow:
    ;; Reset tick to 0
    xor a ; ld a, 0
    ld [tick], a

    ;; Check if we need to perform a row break or pattern break
    ld a, [row_break]
    cp 0
    jr z, .no_break

    ;; These are offset by one so we can check to see if they've
    ;; been modified
    dec a
    ld b, a

    ld a, [next_order]
    cp 0

    ;; Maybe use HL instead?
    push af
    ld a, 0
    ld [next_order], a
    ld [row_break], a
    pop af

    jr z, _neworder

    dec a
    add a ; multiply order by 2 (they are words)

    jr _update_current_order

.no_break:
    ;; Increment row.
    ld a, [row]
    inc a
    ld b, a
    cp PATTERN_LENGTH
    jr nz, _noreset

    ld b, 0
_neworder:
    ;; Increment order and change loaded patterns
    ld a, [order_cnt]
    ld c, a
    ld a, [current_order]
    add a, 2
    cp c
    jr nz, _update_current_order
    ld a, 0
_update_current_order:
    ;; Call with:
    ;; A: The order to load
    ;; B: The row for the order to start on
    ld [current_order], a
    ld c, a
    call _refresh_patterns

_noreset:
    ld a, b
    ld [row], a

    IF DEF(PREVIEW_MODE)
    db $fd ; Signal to the emulator to update the interface
    ENDC
    ret

_halt:
    ; Do nothing, forever
    halt
    nop
    jr _halt